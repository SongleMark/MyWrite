#include <iostream>

Question 一: C和C++的区别 ?
/// Answer: 
/**************************************************************************************************************************************  
 *  1. C是一个结构化语言，它的重点在于算法和数据结构。C程序的设计首要考虑的是如何通过一个过程，对输入（或环境条件）进行运算处理得到输出（或实现过程（事务）控制）。
 *  2. C++，首要考虑的是如何构造一个对象模型，让这个模型能够契合与之对应的问题域，这样就可以通过获取对象的状态信息得到输出或实现过程（事务）控制。 所以C与C++的最大区别在于它们的用于解决问题的思想方法不一样。之所以说C++比C更先进，是因为“ 设计这个概念已经被融入到C++之中 ”。
 *	3. C为面向过程开发，C++为面向对象开发，则考虑的是如何将现实中的问题抽象成一个对象模型，通过该模型可以解决相对应的问题
 ****************************************************************************************************************************************/

Question 二: const 作用/用途
/// Answer:
/***************************************************************************************************************************************
 *  Int  const  *p;         // 指针指向可变，但是p指针指向的地址中的值是个常量
 *  Int  * const  p;	    // 指针指向是不可变的，但是p指向的地址中的变量是可变的；
 *  Int  const  * const p ; // 指针指向不可变，但是指向的地址的值也是不可变的；
 *  在c语言中，一个普通指针可以指向const修饰的变量，编译器会报警告，但是允许编译通过；
 *
 *  c++中，
 *  Int 	a ;
 *  const  int   b;         //  等价于  int const b;	b定义好值后就不能在改变了 
 *
 *  int  *pa=&a;   // 可以
 *  int  *pb=&b;   // error，不可以
 *  普通指针不可以指向一个只读的变量；我们经常使用指针修改变量值，如果这个值不能修改了，该指针的意义也不存在了
 * const  int  *ppa =&a;    // 可以
 * const  int  *ppb=&b;     // 可以  
 * const 修饰的指针，既可以指向普通变量，也可以指向const修饰的变量

 * int  &pa=a;   // 可以
 * int  &pb=b;   // error，不可以

 * const  int  &ppa =a;  // 可以
 * const  int  &ppb=b;   // 可以  

 * Const 修饰引用和指针有什么好处呢？

 * 总结：
 * 1 .普通指针不能指向一个不能改变数值的变量（即const修饰的变量）；
 （我们经常使用指针来修改指向地址的变量值，如果该变量是不可改变的，比如const修饰的只读变量，即有冲突，所以不允许）
 * 2 . const 修饰的指针：
 * Int	 cosnt  *p ，指针指向可改变，但其指向地址中的值不能改变，即指向一个普通变量，那么不能通过该指针进行变量的修改；除了可以指向普通变量，也可以指向一个不能改变数值的变量；比如const修饰的变量；
 * Int  *  const  p, 指针指向不可变，但是其指向的变量可以更改，所以它不能指向const修饰的变量；
 * Const 修饰的指针既可以指向普通变量，也可以指向只读变量，所以经常在函数参数中使用；
 * 3. 修饰类成员函数，类的const成员函数表示不更该成员变量的值
 *
 * ************************************************************************************************************************************/

Question 三: static 作用/用途
/// Answer:
/***************************************************************************************************************************************
 * 1.  函数体内 static 变量的作用范围为该函数体，不同于 auto 变量， 该变量的内存只被分配一次，因此其值在下次调用时仍维持上次的值
 *
 * 2.  在模块内的 static 全局变量可以被模块内所有函数访问，但不能被模块外其他函数访问
 *
 * 3.  在模块内的static 函数只可被这一模块内的其他函数调用，这个函数的使用范围被限制在声明它的模块内
 *
 * 4.  在类的static 成员变量属于整个类所拥有，对类的所以对象只有一份拷贝
 *
 * 5.  在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访问类的 static 成员变量
 *
 **************************************************************************************************************************************/

Question 四: 指针和引用的区别
/// Answer:
/***************************************************************************************************************************************
 * 1. 引用是变量的一个别名，内部实现是只读指针
 *
 * 2. 引用只能在初始化时被赋值，其他时候值不能被改变，指针的值可以在任何时候被改变
 *
 * 3. 引用不能为NULL，指针可以为NULL
 *
 * 4. 引用变量内存单元保存的是被引用变量的地址
 *
 * 5. “sizeof 引用" = 指向变量的大小 ， "sizeof 指针"= 指针本身的大小
 *
 * 6. 引用可以取地址操作，返回的是被引用变量本身所在的内存单元地址
 *
 * 7. 引用使用在源代码级相当于普通的变量一样使用，做函数参数时，内部传递的实际是变量地址
 *
 * ************************************************************************************************************************************/

Question 五: malloc/free 和 new/delete
/// Answer:
/***************************************************************************************************************************************
 * 1. malloc与free是C++/C语言的标准库函数，new/delete是C++的运算符。它们都可用于申请动态内存和释放内存。
 *
 * 2. 对于非内部数据类型的对象而言，光用maloc/free无法满足动态对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析       构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free
 *
 * 3. 因此C++语言需要一个能完成动态内存分配和初始化工作的运算符new，以一个能完成清理与释放内存工作的运算符delete。注意new/delete不是库函       数。
 *
 **************************************************************************************************************************************/

Question 六: 进程间通信方式
/// Answer
/***************************************************************************************************************************************
 * 1. 管道(流管道和有名管道)
 *
 * 2. 信号(signal)
 *
 * 3. 共享内存(shmget ...)
 *
 * 4. 信号量(semophore)
 *
 * 5. 消息队列(message queue )
 *
 * 6. 套接字
 *
 **************************************************************************************************************************************/

